

### 1. 事务的隔离级别

事务基本原则, ACID原则

A=事务的一组操作, 同时成功, 同时失败.

C=一致性, 数据完整性, 让db从1个正确的状态变为另一个正确的状态, C其实是通过AID保障的. AID都是db的特性

I=同一时间, 同一数据只有1个事务访问, 事务之间是隔离的, 没有干扰的.

D=持久性, 事务生效后, 不能回滚.



mysql中的事务隔离界别和解决的问题

数据遇到的 问题:

1. 脏读: 某事务读取到了另一个尚未提交的事务, 另一个事务回滚, 导致A读到了脏数据.

2. 不可重复读: 更多的侧重update操作, A事务多次读取同一数据, 另一个事务在这个过程中更新了数据并提交, 导致A多次读取的数据不一致.

3. 幻读: 更多的侧重于insert和delete, A事务对符合某条件的数据进行操作, B事务过程中插入了新数据并且提交, A发现事务结束后仍然有操作没生效. 

   

mysql的4中隔离级别分别可以解决对应的问题

| 隔离级别                            | 存在脏读 | 存在不可重复读 | 存在幻读 |
| ----------------------------------- | -------- | -------------- | -------- |
| 读未提交(Read-Uncommitted)          | Y        | Y              | Y        |
| 不可重复读/读已提交(Read-Committed) | N        | Y              | Y        |
| 可重复读(Read-repeated)             | N        | N              | Y        |
| 串行化(Serializable)                | N        | N              | N        |

mysql中锁相关:

* 绝大部分rdmms都有mvcc机制(**多版本并发控制**), 与之对比的是lbcc(基于锁的并发控制). 其中lbcc的基本是s和x锁, 即读的时候不锁读操作, 写的时候锁所有操作, 本质是读写串行化.

* 读分成2类, 快照读/当前读, 快照读取的是历史版本的快找数据(最新版本的数据可能在被另一个事务操作). 当前读读取的是记录的最新版本, 会对返回的数据加锁. 简单的`select from where`都是快照读. 如果是`select from where for update`就是当前读, 除此之外还有insert, update等dml.

* innoDB中通过mvcc机制解决了幻读. 因为他读的时候锁的是记录们和记录之间的范围(间隙锁), 使得范围的数据也无法插入. 标准的rr中是有幻读问题的.

* 死锁: 死锁的本质是不同事务之间数据有交叉, 同时操作的顺序不一致.

  如, 第一个事务为

  ```mysql
  select * from table where id = 1 for update;
  update table set field = 'xxx' where id = 2;
  ```

  第二个事务为

  ```mysql
  delete table where id = 2;
  delete table where id = 1;
  ```

  因为获取锁是逐条进行的, 因此, 第一个事务拿到了id=1的锁, 操作2的时候等待id=2的锁释放; 同时, 第二个事务率先获取了id=2的锁, 然后等待别的事务释放id=1的锁, 死锁发生.

  * RC和RR的主要区别是RR有gap锁



### 2. b+树索引

